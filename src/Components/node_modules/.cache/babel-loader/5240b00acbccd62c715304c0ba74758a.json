{"ast":null,"code":"/** \n * Copyright (c) INOVUA SOFTWARE TECHNOLOGIES.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _default = function _default(_ref) {\n  var dragTarget = _ref.dragTarget,\n      dropTarget = _ref.dropTarget,\n      dragMinIndex = _ref.dragMinIndex,\n      dragMaxIndex = _ref.dragMaxIndex,\n      dragRange = _ref.dragRange,\n      ranges = _ref.ranges,\n      rtl = _ref.rtl,\n      dir = _ref.dir,\n      validDropPositions = _ref.validDropPositions;\n  ranges = ranges || [];\n  var dragIndex = dragRange.index;\n  var draggingLocked = dragRange.computedLocked;\n  var locked = draggingLocked;\n\n  var isValid = function isValid(i) {\n    if (i === undefined) {\n      return false;\n    }\n\n    var validDropIndex = dropTarget === 'group' || !validDropPositions || validDropPositions[i];\n\n    if (dragMinIndex !== undefined && i < dragMinIndex || dragMaxIndex !== undefined && i > dragMaxIndex || !validDropIndex || i > ranges.length) {\n      return false;\n    }\n\n    return true;\n  };\n\n  var searchInRanges = dragTarget != dropTarget ? ranges : dir == 1 ? ranges.slice(dragIndex) : ranges.slice(0, dragIndex);\n  var currentRange;\n  var halfSize;\n  var thisDir;\n  var index;\n  var foundIndex;\n\n  for (var i = 0, len = searchInRanges.length; i < len; i++) {\n    currentRange = searchInRanges[i];\n\n    if (!currentRange) {\n      continue;\n    }\n\n    index = currentRange.index;\n    thisDir = index <= dragIndex || dragTarget !== dropTarget ? -1 : 1;\n    halfSize = (currentRange.right - currentRange.left) / 2;\n\n    if (thisDir > 0) {\n      if (isValid(index + 1) && (rtl ? dragRange.left <= currentRange.right - halfSize : dragRange.right >= currentRange.left + halfSize)) {\n        foundIndex = index + 1;\n      }\n    } else {\n      if (isValid(index) && (rtl ? dragRange.right > currentRange.right - halfSize : dragRange.left < currentRange.left + halfSize)) {\n        foundIndex = index;\n\n        if (dropTarget !== dragTarget || dir === -1) {\n          break;\n        }\n      }\n    }\n  }\n\n  if (dragTarget === dropTarget) {\n    if (foundIndex === dragIndex + 1) {\n      foundIndex++;\n    } else if (foundIndex === undefined) {\n      foundIndex = dragIndex === ranges.length - 1 || dragIndex === 0 ? dragIndex : dir > 1 ? ranges.length : undefined;\n    }\n  } else if (foundIndex === undefined) {\n    foundIndex = ranges.length;\n  }\n\n  if (!isValid(foundIndex)) {\n    foundIndex = undefined;\n  }\n\n  if (dragMinIndex !== undefined && foundIndex < dragMinIndex) {\n    foundIndex = dragMinIndex;\n  }\n\n  if (dragMaxIndex !== undefined && foundIndex > dragMaxIndex) {\n    foundIndex = dragMaxIndex;\n  }\n\n  if (!isValid(foundIndex)) {\n    foundIndex = dragIndex;\n  }\n\n  if (!isValid(foundIndex)) {\n    foundIndex = undefined;\n  }\n\n  if (isValid(foundIndex) && ranges[foundIndex]) {\n    locked = ranges[foundIndex].computedLocked;\n  }\n\n  var initialLocked = locked;\n\n  if (dir === 1) {\n    var targetRange = ranges[foundIndex];\n    var beforeTargetRange = ranges[foundIndex - 1];\n    var afterTargetRange = ranges[foundIndex + 1];\n\n    if (targetRange && !targetRange.computedLocked) {\n      if (rtl) {\n        if (dragRange.left < targetRange.right) {\n          locked = targetRange.computedLocked;\n        } else {\n          locked = beforeTargetRange ? beforeTargetRange.computedLocked : initialLocked;\n        }\n      } else {\n        if (dragRange.right > targetRange.left) {\n          locked = targetRange.computedLocked;\n        } else {\n          locked = beforeTargetRange ? beforeTargetRange.computedLocked : initialLocked;\n        }\n      }\n    } else if (targetRange && targetRange.computedLocked === 'end') {\n      if (rtl) {\n        locked = dragRange.left < targetRange.right ? 'end' : beforeTargetRange ? beforeTargetRange.computedLocked : initialLocked;\n      } else {\n        locked = dragRange.right > targetRange.left ? 'end' : beforeTargetRange ? beforeTargetRange.computedLocked : initialLocked;\n      }\n    } else if (afterTargetRange && !afterTargetRange.computedLocked && (rtl ? dragRange.left > afterTargetRange.right : dragRange.right > afterTargetRange.left)) {\n      locked = null;\n    } else if (beforeTargetRange && beforeTargetRange.computedLocked === 'end') {\n      locked = 'end';\n    }\n  }\n\n  if (dir === -1) {\n    var _targetRange = ranges[foundIndex];\n    var _beforeTargetRange = ranges[foundIndex - 1];\n\n    if (_beforeTargetRange && !_beforeTargetRange.computedLocked && (rtl ? dragRange.right > _beforeTargetRange.left : dragRange.left < _beforeTargetRange.right)) {\n      locked = null;\n    } else if (_beforeTargetRange && _beforeTargetRange.computedLocked === 'start' && (rtl ? dragRange.right > _beforeTargetRange.left : dragRange.left < _beforeTargetRange.right)) {\n      locked = 'start';\n    } else if (_targetRange && _targetRange.computedLocked === 'end' && (rtl ? dragRange.right > _targetRange.left : dragRange.left < _targetRange.right)) {\n      locked = 'end';\n    }\n  }\n\n  if (draggingLocked === 'start' && ranges[foundIndex] && ranges[foundIndex].computedLocked === 'start' && locked == null) {\n    foundIndex++;\n  }\n\n  return {\n    index: foundIndex,\n    locked: locked\n  };\n};\n\nexports.default = _default;","map":{"version":3,"sources":["/Users/kathiavargas/node_modules/@inovua/reactdatagrid-community/Layout/ColumnLayout/HeaderLayout/getDropIndex.js"],"names":["Object","defineProperty","exports","value","default","_default","_ref","dragTarget","dropTarget","dragMinIndex","dragMaxIndex","dragRange","ranges","rtl","dir","validDropPositions","dragIndex","index","draggingLocked","computedLocked","locked","isValid","i","undefined","validDropIndex","length","searchInRanges","slice","currentRange","halfSize","thisDir","foundIndex","len","right","left","initialLocked","targetRange","beforeTargetRange","afterTargetRange","_targetRange","_beforeTargetRange"],"mappings":"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","sourcesContent":["/** \n * Copyright (c) INOVUA SOFTWARE TECHNOLOGIES.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _default = function _default(_ref) {\n  var dragTarget = _ref.dragTarget,\n      dropTarget = _ref.dropTarget,\n      dragMinIndex = _ref.dragMinIndex,\n      dragMaxIndex = _ref.dragMaxIndex,\n      dragRange = _ref.dragRange,\n      ranges = _ref.ranges,\n      rtl = _ref.rtl,\n      dir = _ref.dir,\n      validDropPositions = _ref.validDropPositions;\n  ranges = ranges || [];\n  var dragIndex = dragRange.index;\n  var draggingLocked = dragRange.computedLocked;\n  var locked = draggingLocked;\n\n  var isValid = function isValid(i) {\n    if (i === undefined) {\n      return false;\n    }\n\n    var validDropIndex = dropTarget === 'group' || !validDropPositions || validDropPositions[i];\n\n    if (dragMinIndex !== undefined && i < dragMinIndex || dragMaxIndex !== undefined && i > dragMaxIndex || !validDropIndex || i > ranges.length) {\n      return false;\n    }\n\n    return true;\n  };\n\n  var searchInRanges = dragTarget != dropTarget ? ranges : dir == 1 ? ranges.slice(dragIndex) : ranges.slice(0, dragIndex);\n  var currentRange;\n  var halfSize;\n  var thisDir;\n  var index;\n  var foundIndex;\n\n  for (var i = 0, len = searchInRanges.length; i < len; i++) {\n    currentRange = searchInRanges[i];\n\n    if (!currentRange) {\n      continue;\n    }\n\n    index = currentRange.index;\n    thisDir = index <= dragIndex || dragTarget !== dropTarget ? -1 : 1;\n    halfSize = (currentRange.right - currentRange.left) / 2;\n\n    if (thisDir > 0) {\n      if (isValid(index + 1) && (rtl ? dragRange.left <= currentRange.right - halfSize : dragRange.right >= currentRange.left + halfSize)) {\n        foundIndex = index + 1;\n      }\n    } else {\n      if (isValid(index) && (rtl ? dragRange.right > currentRange.right - halfSize : dragRange.left < currentRange.left + halfSize)) {\n        foundIndex = index;\n\n        if (dropTarget !== dragTarget || dir === -1) {\n          break;\n        }\n      }\n    }\n  }\n\n  if (dragTarget === dropTarget) {\n    if (foundIndex === dragIndex + 1) {\n      foundIndex++;\n    } else if (foundIndex === undefined) {\n      foundIndex = dragIndex === ranges.length - 1 || dragIndex === 0 ? dragIndex : dir > 1 ? ranges.length : undefined;\n    }\n  } else if (foundIndex === undefined) {\n    foundIndex = ranges.length;\n  }\n\n  if (!isValid(foundIndex)) {\n    foundIndex = undefined;\n  }\n\n  if (dragMinIndex !== undefined && foundIndex < dragMinIndex) {\n    foundIndex = dragMinIndex;\n  }\n\n  if (dragMaxIndex !== undefined && foundIndex > dragMaxIndex) {\n    foundIndex = dragMaxIndex;\n  }\n\n  if (!isValid(foundIndex)) {\n    foundIndex = dragIndex;\n  }\n\n  if (!isValid(foundIndex)) {\n    foundIndex = undefined;\n  }\n\n  if (isValid(foundIndex) && ranges[foundIndex]) {\n    locked = ranges[foundIndex].computedLocked;\n  }\n\n  var initialLocked = locked;\n\n  if (dir === 1) {\n    var targetRange = ranges[foundIndex];\n    var beforeTargetRange = ranges[foundIndex - 1];\n    var afterTargetRange = ranges[foundIndex + 1];\n\n    if (targetRange && !targetRange.computedLocked) {\n      if (rtl) {\n        if (dragRange.left < targetRange.right) {\n          locked = targetRange.computedLocked;\n        } else {\n          locked = beforeTargetRange ? beforeTargetRange.computedLocked : initialLocked;\n        }\n      } else {\n        if (dragRange.right > targetRange.left) {\n          locked = targetRange.computedLocked;\n        } else {\n          locked = beforeTargetRange ? beforeTargetRange.computedLocked : initialLocked;\n        }\n      }\n    } else if (targetRange && targetRange.computedLocked === 'end') {\n      if (rtl) {\n        locked = dragRange.left < targetRange.right ? 'end' : beforeTargetRange ? beforeTargetRange.computedLocked : initialLocked;\n      } else {\n        locked = dragRange.right > targetRange.left ? 'end' : beforeTargetRange ? beforeTargetRange.computedLocked : initialLocked;\n      }\n    } else if (afterTargetRange && !afterTargetRange.computedLocked && (rtl ? dragRange.left > afterTargetRange.right : dragRange.right > afterTargetRange.left)) {\n      locked = null;\n    } else if (beforeTargetRange && beforeTargetRange.computedLocked === 'end') {\n      locked = 'end';\n    }\n  }\n\n  if (dir === -1) {\n    var _targetRange = ranges[foundIndex];\n    var _beforeTargetRange = ranges[foundIndex - 1];\n\n    if (_beforeTargetRange && !_beforeTargetRange.computedLocked && (rtl ? dragRange.right > _beforeTargetRange.left : dragRange.left < _beforeTargetRange.right)) {\n      locked = null;\n    } else if (_beforeTargetRange && _beforeTargetRange.computedLocked === 'start' && (rtl ? dragRange.right > _beforeTargetRange.left : dragRange.left < _beforeTargetRange.right)) {\n      locked = 'start';\n    } else if (_targetRange && _targetRange.computedLocked === 'end' && (rtl ? dragRange.right > _targetRange.left : dragRange.left < _targetRange.right)) {\n      locked = 'end';\n    }\n  }\n\n  if (draggingLocked === 'start' && ranges[foundIndex] && ranges[foundIndex].computedLocked === 'start' && locked == null) {\n    foundIndex++;\n  }\n\n  return {\n    index: foundIndex,\n    locked: locked\n  };\n};\n\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}