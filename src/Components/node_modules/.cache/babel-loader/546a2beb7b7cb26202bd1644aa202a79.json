{"ast":null,"code":"var _jsxFileName = \"/Users/kathiavargas/Desktop/dataStudio/my_app/src/Components/GeoChart.js\";\nimport React, { useRef, useEffect, useState } from \"react\";\nimport { select, geoPath, geoMercator, min, max, scaleLinear } from \"d3\";\nimport useResizeObserver from \"./useResizeObserver\"; //import data from \"./states.json\"\n\n/**\n * Component that renders a map of Germany.\n */\n\nfunction GeoChart({\n  data,\n  property\n}) {\n  const svgRef = useRef();\n  const wrapperRef = useRef(); //const dimensions = useResizeObserver(wrapperRef);\n\n  const [selectedState, setSelectedState] = useState(null);\n  const width = 400;\n  const height = 800; // will be called initially and on every data change\n\n  useEffect(() => {\n    const svg = select(svgRef.current);\n    const minProp = min(data.features, feature => feature.properties[property]);\n    const maxProp = max(data.features, feature => feature.properties[property]);\n    const colorScale = scaleLinear().domain([minProp, maxProp]).range([\"#ccc\", \"red\"]); // use resized dimensions\n    // but fall back to getBoundingClientRect, if no dimensions yet.\n    //const { width, height } =\n    //dimensions || wrapperRef.current.getBoundingClientRect();\n    // projects geo-coordinates on a 2D plane\n\n    const projection = geoMercator().fitSize([width, height], selectedState || data).precision(100); // takes geojson data,\n    // transforms that into the d attribute of a path element\n\n    const pathGenerator = geoPath().projection(projection); // render each country\n\n    svg.selectAll(\".country\").data(data.features).join(\"path\") // .on(\"click\", feature => {\n    //   setSelectedCountry(selectedCountry === feature ? null : feature);\n    // })\n    .attr(\"class\", \"country\").transition().attr(\"fill\", feature => colorScale(feature.properties[property])).attr(\"d\", feature => pathGenerator(feature)); // render text\n\n    svg.selectAll(\".label\").data([selectedState]).join(\"text\").attr(\"class\", \"label\").text(feature => feature && feature.properties.name + \": \" + feature.properties[property].toLocaleString()).attr(\"x\", 10).attr(\"y\", 25);\n  }, [data, property, selectedState]);\n  return /*#__PURE__*/React.createElement(\"div\", {\n    ref: wrapperRef,\n    style: {\n      marginBottom: \"2rem\"\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 73,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(\"svg\", {\n    ref: svgRef,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 74,\n      columnNumber: 7\n    }\n  }));\n}\n\nexport default GeoChart;","map":{"version":3,"sources":["/Users/kathiavargas/Desktop/dataStudio/my_app/src/Components/GeoChart.js"],"names":["React","useRef","useEffect","useState","select","geoPath","geoMercator","min","max","scaleLinear","useResizeObserver","GeoChart","data","property","svgRef","wrapperRef","selectedState","setSelectedState","width","height","svg","current","minProp","features","feature","properties","maxProp","colorScale","domain","range","projection","fitSize","precision","pathGenerator","selectAll","join","attr","transition","text","name","toLocaleString","marginBottom"],"mappings":"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","sourcesContent":["import React, { useRef, useEffect, useState } from \"react\";\nimport { select, geoPath, geoMercator, min, max, scaleLinear } from \"d3\";\nimport useResizeObserver from \"./useResizeObserver\";\n//import data from \"./states.json\"\n\n/**\n * Component that renders a map of Germany.\n */\n\nfunction GeoChart({ data, property }) {\n  const svgRef = useRef();\n  const wrapperRef = useRef();\n  //const dimensions = useResizeObserver(wrapperRef);\n  const [selectedState, setSelectedState] = useState(null);\n  const width = 400;\n  const height = 800;\n\n  // will be called initially and on every data change\n  useEffect(() => {\n    const svg = select(svgRef.current);\n\n    const minProp = min(data.features, feature => feature.properties[property]);\n    const maxProp = max(data.features, feature => feature.properties[property]);\n    const colorScale = scaleLinear()\n      .domain([minProp, maxProp])\n      .range([\"#ccc\", \"red\"]);\n\n    // use resized dimensions\n    // but fall back to getBoundingClientRect, if no dimensions yet.\n    //const { width, height } =\n      //dimensions || wrapperRef.current.getBoundingClientRect();\n\n    // projects geo-coordinates on a 2D plane\n    const projection = geoMercator()\n      .fitSize([width, height], selectedState || data)\n      .precision(100);\n\n    // takes geojson data,\n    // transforms that into the d attribute of a path element\n    const pathGenerator = geoPath().projection(projection);\n\n    // render each country\n    svg\n      .selectAll(\".country\")\n      .data(data.features)\n      .join(\"path\")\n      // .on(\"click\", feature => {\n      //   setSelectedCountry(selectedCountry === feature ? null : feature);\n      // })\n      .attr(\"class\", \"country\")\n      .transition()\n      .attr(\"fill\", feature => colorScale(feature.properties[property]))\n      .attr(\"d\", feature => pathGenerator(feature));\n\n    // render text\n    svg\n      .selectAll(\".label\")\n      .data([selectedState])\n      .join(\"text\")\n      .attr(\"class\", \"label\")\n      .text(\n        feature =>\n          feature &&\n          feature.properties.name +\n            \": \" +\n            feature.properties[property].toLocaleString()\n      )\n      .attr(\"x\", 10)\n      .attr(\"y\", 25);\n  }, [data, property, selectedState]);\n\n  return (\n    <div ref={wrapperRef} style={{ marginBottom: \"2rem\" }}>\n      <svg ref={svgRef}></svg>\n    </div>\n  );\n}\n\nexport default GeoChart;\n"]},"metadata":{},"sourceType":"module"}